/*	==================== _insert ====================	This function uses recursion to insert the new data 	into a leaf node in the AVL tree.	Pre    Application has called AVL_Insert, which passes 	       root and data pointers.	Post   Data have been inserted.	Return pointer to [potentially] new root.*/NODE* _insert (AVL_TREE* tree,   NODE* root,                NODE*     newPtr, bool* taller){//	Statements 	if (!root)	   {	    // Insert at root 	    root     = newPtr;	    *taller  = true;	    return   root;	   } // if NULL tree  	if (tree->compare(newPtr->dataPtr, 	                  root->dataPtr) < 0)	   {	    // newData < root -- go left 	    root->left = _insert(tree,   root->left, 	                         newPtr, taller);	    if (*taller)	       // Left subtree is taller 	       switch (root->bal)	          {	           case LH:  // Was left high--rotate 	                   root = insLeftBal (root, taller);	                   break;	           case EH:  // Was balanced--now LH 	                   root->bal = LH;	                   break;	           case RH:  // Was right high--now EH 	                   root->bal = EH;	                   *taller   = false;	                   break;	          } // switch 	       return root; 	   } // new < node 	else 	    // new data >= root data 	    {	     root->right = _insert (tree,   root->right, 	                            newPtr, taller);	     if (*taller)	        // Right subtree is taller 	        switch (root->bal)	            {	             case LH:  // Was left high--now EH 	                       root->bal = EH;	                       *taller   = false;	                       break;	             	             case EH:  // Was balanced--now RH 	                       root->bal = RH;	                       break;		             case RH:  // Was right high--rotate 	                       root = insRightBal	                                  (root, taller);	                       break;	            } // switch 	     return root;	     } // else new data >= root data 	return root;}	// _insert 