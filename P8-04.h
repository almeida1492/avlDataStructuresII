/*	==================== _insert ====================	This function uses recursion to insert the new data 	into a leaf node in the AVL tree.	Pre    Application has called AVL_Insert, which passes 	       root and data pointers.	Post   Data have been inserted.	Return pointer to [potentially] new root.*/AVL_NODE* _avl_insert (AVL_TREE* tree, AVL_NODE* root, AVL_NODE* newPtr, bool* taller){//	Statements 	if (!root){	    // Insert at root 	    root = newPtr; 	    *taller  = true;	    return   root;	   } // if NULL tree  	if (tree->compare(newPtr->dataPtr, root->dataPtr) < 0){ // newData < root -- go left 	    root->left = _avl_insert(tree, root->left, newPtr, taller);	    if (*taller)	       // Left subtree is taller 	       switch (root->bal)	          {	           case LH:  // Was left high--rotate 	                   root = insLeftBal(root, taller);	                   break;	           case EH:  // Was balanced--now LH 	                   root->bal = LH;	                   break;	           case RH:  // Was right high--now EH 	                   root->bal = EH;	                   *taller   = false;	                   break;	          } // switch 	       return root; 	   } // new < node 	else {	// new data >= root data	     	    root->right = _avl_insert (tree, root->right, newPtr, taller);	     if (*taller)	        // Right subtree is taller 	        switch (root->bal)	            {	             case LH:  // Was left high--now EH 	                       root->bal = EH;	                       *taller   = false;	                       break;	             	             case EH:  // Was balanced--now RH 	                       root->bal = RH;	                       break;		             case RH:  // Was right high--rotate 	                       root = insRightBal	                                  (root, taller);	                       break;	            } // switch 	     return root;	     } // else new data >= root data 	return root;}	// _insert 